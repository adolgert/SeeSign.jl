var documenterSearchIndex = {"docs":
[{"location":"getting_started/#Getting-Started-with-SeeSign.jl","page":"Getting Started","title":"Getting Started with SeeSign.jl","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This is an example of using Literate.jl to create executable documentation.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"SeeSign.jl is a simulation framework built on top of CompetingClocks.jl for event-driven simulations with dependency tracking.","category":"page"},{"location":"getting_started/#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"First, let's import the package:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using SeeSign","category":"page"},{"location":"getting_started/#Simple-Example","page":"Getting Started","title":"Simple Example","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Here's how you would set up a basic simulation: (This is just an example structure - you'll replace this with actual working code)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"println(\"This is a placeholder example for Literate.jl integration\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This is a placeholder example for Literate.jl integration\n","category":"page"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"As you develop more examples, you can add them as .jl files in the literate_src/ directory. They will be automatically converted to markdown and included in the documentation.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"plan/#Plan","page":"Plan","title":"Plan","text":"","category":"section"},{"location":"plan/#Current-Features","page":"Plan","title":"Current Features","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Rule-based events\nSampling methods\nDirac delta function times (for ODEs)\nDeterministic\nFerret out uses of Set that cause randomization.\nRe-enabling of events\nRules that depend on events instead of just states.\nMacro and struct for event(key)\nObservers on events\nObservers of state changes\nImmediate events","category":"page"},{"location":"plan/#Future-features","page":"Plan","title":"Future features","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Importance sampling\nPregeneration of all rule-based events.\nTransactional firing (for estimation of derivatives)\nHMC sampling from trajectories","category":"page"},{"location":"plan/#Example-Simulations","page":"Plan","title":"Example Simulations","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Movement and infection.\nMove, infect, age, birth.\nPolicy-driven movement.\nQueuing model.\nChemical equations.\nDrone search pattern with geometry.\nHMC for house-to-house infestation.\nJob shop problem.\nCars driving on a map.","category":"page"},{"location":"plan/#Example-Uses-of-Simulations","page":"Plan","title":"Example Uses of Simulations","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Hook into standard Julia analysis tools.\nSampling rare events.\nParameter fitting to world data.\nOptimization of parameters to minimize a goal function.\nHMC on trajectories to find a most likely event stream.\nPOMDP","category":"page"},{"location":"plan/#Performance-Questions","page":"Plan","title":"Performance Questions","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"How stable can I make the type system in the running simulation? It uses Events in places and tuples in others.\nThe TrackedEntry needs to be timed and gamed.\nCould the TrackedEntry be an N-dimensional array? Could each entry be an array? A dictionary?\nCan the main simulation look over the keys to determine types before it instantiates?\nThe depnet is absolutely wrong for the current main loop. It might be closer to right for another mainloop. Should try various implementations.\nMeasure performance with profiling. Look for the memory leaks.","category":"page"},{"location":"plan/#Improvements-to-the-Framework-User-Interface","page":"Plan","title":"Improvements to the Framework User Interface","text":"","category":"section"},{"location":"plan/#generator-functions-use-do-function-syntax-so-make-it-easier.","page":"Plan","title":"generator functions use do-function syntax so make it easier.","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Create a macro for generator functions that looks like you call generate(event) but really calls a do-function callback underneath.","category":"page"},{"location":"plan/#Simplify-enabling/reenabling","page":"Plan","title":"Simplify enabling/reenabling","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Ask the simulation to define the distribution and when but not the sampler, rng, or clock_key.","category":"page"},{"location":"plan/#Explicitly-register-functions","page":"Plan","title":"Explicitly register functions","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"In framework.jl - automatic method generation   function registerevent(eventtype::Type{<:SimEvent}, spec::EventSpec)       # Generate precondition, generators, enable, fire! automatically       # Based on declarative specification   end","category":"page"},{"location":"plan/#Macro-to-say-what-generators-trigger-on","page":"Plan","title":"Macro to say what generators trigger on","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Framework provides path builder   @watches actors[].state  # Instead of [:actors, â„¤, :state]   @watches board[].occupant","category":"page"},{"location":"plan/#Put-common-event-patterns-into-template-structs","page":"Plan","title":"Put common event patterns into template structs","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Framework could provide base types:","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"ActorEvent{T} - for single-actor events\nInteractionEvent{T} - for multi-actor events\nScheduledEvent{T} - for time-based events\nStateTransitionEvent{T} - for state machine transitions","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"or make it a function:   Framework provides factory for common patterns   createstatetransitionevent(       :Break,       fromstate = :working,       tostate = :broken,       ratefield = :faildist,       agetracking = true   )","category":"page"},{"location":"plan/#Put-common-enabling-patterns-into-template-structs","page":"Plan","title":"Put common enabling patterns into template structs","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Common patterns built into framework   abstract type RateModel end   struct ConstantRate <: RateModel; dist; end   struct ActorRate <: RateModel; field::Symbol; end   struct TimeBasedRate <: RateModel; calc::Function; end","category":"page"},{"location":"plan/#Help-build-the-simulation-itself","page":"Plan","title":"Help build the simulation itself","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"In framework.jl   @simulation MySimulation begin       state_type = IndividualState       events = [StartDay, EndDay, Break, Repair]       sampler = CombinedNextReaction","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"  initialize = function(physical, rng)\n      # initialization code\n  end\n\n  stop_when = (physical, step, event, when) -> when > days","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"end","category":"page"},{"location":"plan/#Make-tools-with-which-to-make-simulation-DSLs","page":"Plan","title":"Make tools with which to make simulation DSLs","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"  # Framework should export these primitives\n  export create_generator, register_precondition, add_rate_function\n  export EventSpecification, GeneratorSpec, RateSpec\n\n  # So users can build their own DSLs:\n  macro my_reliability_event(name, spec)\n      quote\n          struct $(esc(name)) <: ActorEvent{IndividualState}\n              actor_idx::Int\n          end\n\n          # Use framework primitives\n          register_precondition($(esc(name)), $(spec.precondition))\n          add_rate_function($(esc(name)), $(spec.rate))\n      end\n  end","category":"page"},{"location":"plan/#Use-traits-more-than-inheritance","page":"Plan","title":"Use traits more than inheritance","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Maybe both traits and hooks, where a user registers a function to call for a particular event.","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"  # Framework defines traits\n  abstract type EventTrait end\n  struct HasActor <: EventTrait end\n  struct HasSchedule <: EventTrait end\n  struct HasInteraction <: EventTrait end\n\n  # Users can mix traits freely\n  event_traits(::Type{<:SimEvent}) = ()\n  event_traits(::Type{Break}) = (HasActor(), HasSchedule())\n\n  # Framework dispatches on traits\n  function generate_precondition(evt::Type{T}) where T\n      traits = event_traits(T)\n      # Compose behavior from traits\n  end","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"This could also help the functions on events.","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"  # Instead of storing functions, use traits\n  abstract type PreconditionTrait end\n  struct StateCheck{S} <: PreconditionTrait\n      required_state::S\n  end\n\n  struct EventConfig{P <: PreconditionTrait}\n      precondition_trait::P\n  end\n\n  # Fast dispatch\n  @inline function check_precondition(evt::ActorEvent, physical, ::StateCheck{S}) where S\n      physical.actors[evt.actor_idx].state == S\n  end","category":"page"},{"location":"plan/#Make-Syntax-Trees-Accessible","page":"Plan","title":"Make Syntax Trees Accessible","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"  # If framework uses macros, expose the AST\n  macro framework_helper(expr)\n      ast = parse_event_ast(expr)\n      # Let users transform it\n      transformed = apply_user_transforms(ast)\n      return generate_code(transformed)\n  end\n\n  # Users can register transforms\n  register_ast_transform!(my_reliability_transform)","category":"page"},{"location":"plan/#Macro-advice","page":"Plan","title":"Macro advice","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Macro Design Best Practices","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"AVOID These Patterns:","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"  # 1. Rigid syntax requirements\n  @framework_event name::Type = value  # Forces specific syntax\n\n  # 2. Closed evaluation contexts\n  @framework_event Break begin\n      eval(:(struct Break ... end))  # Evaluates in framework module\n  end\n\n  # 3. Monolithic macros\n  @define_entire_event Break working broken fail_dist ...","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"PREFER These Patterns:","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"  # 1. Composable macro fragments\n  @event_struct Break actor_idx::Int\n  @event_precondition Break (evt, phys) -> phys.actors[evt.actor_idx].state == working\n  @event_rate Break (evt, phys) -> phys.params[evt.actor_idx].fail_dist\n\n  # 2. Pass-through to user context\n  macro framework_helper(name, user_expr)\n      quote\n          # Evaluate in caller's context\n          local user_result = $(esc(user_expr))\n          framework_process($(QuoteNode(name)), user_result)\n      end\n  end\n\n  # 3. Metadata-based approach\n  @event_metadata Break begin\n      traits = [:actor_based, :state_transition]\n      watches = [:actors]\n      # Users can add custom metadata\n  end","category":"page"},{"location":"plan/#Sample-Implementation","page":"Plan","title":"Sample Implementation","text":"","category":"section"},{"location":"plan/#Of-a-framework-that-enables-user-DSLs","page":"Plan","title":"Of a framework that enables user DSLs","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"  # Framework provides:\n  module SeeSignFramework\n\n  # Low-level registration API\n  function register_event_type(T::Type, config::EventConfig)\n      # Store in global registry\n  end\n\n  # Composable specifications\n  # This should use parametric types\n  struct EventConfig{P,G,E,F}\n      precondition::Union{Function, Nothing}\n      generators::Vector{GeneratorSpec}\n      enable::Union{Function, Nothing}\n      fire::Union{Function, Nothing}\n      metadata::Dict{Symbol, Any}\n  end\n\n  # Give the parametric event config a solid constructor.\n  function actor_event_behavior(;\n      required_state::Symbol,\n      rate_field::Symbol,\n      fire_action::Function\n  )\n      EventBehavior(\n          # Specialized, inlinable functions\n          (evt, physical) -> getfield(physical.actors[evt.actor_idx], :state) == required_state,\n          (evt, sampler, physical, when, rng) -> enable!(\n              sampler,\n              clock_key(evt),\n              getfield(getfield(physical.params[evt.actor_idx], rate_field)),\n              when, when, rng\n          ),\n          fire_action,\n          default_actor_generators()\n      )\n  end\n\n  end # module\n\n  # User's DSL:\n  module ReliabilityDSL\n  using SeeSignFramework\n\n  macro reliability_event(name, from, to, rate_field)\n      quote\n          struct $(esc(name)) <: SimEvent\n              actor_idx::Int\n          end\n\n          config = actor_event_config(\n              precondition_state = $(esc(from)),\n              rate_distribution = evt -> evt.physical.params[evt.actor_idx].$rate_field,\n              fire_action = (evt, phys, when) -> begin\n                  phys.actors[evt.actor_idx].state = $(esc(to))\n                  # Custom reliability logic here\n              end\n          )\n\n          register_event_type($(esc(name)), config)\n      end\n  end\n\n  # Clean syntax for users\n  @reliability_event Break working broken fail_dist\n  @reliability_event Repair broken ready repair_dist\n\n  end # module","category":"page"},{"location":"plan/#Of-an-ActorEvent{T}","page":"Plan","title":"Of an ActorEvent{T}","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"  abstract type ActorEvent{T} <: SimEvent end\n\n  # Default implementation that concrete types can override\n  actor_index(evt::ActorEvent) = evt.actor_idx\n  actor_collection(::Type{<:ActorEvent{T}}) where T = :actors\n  actor_state_field(::Type{<:ActorEvent{T}}) where T = :state\n\n  # Generic precondition - can be overridden\n  function precondition(evt::E, physical) where E <: ActorEvent\n      actor_idx = actor_index(evt)\n      checkbounds(Bool, getfield(physical, actor_collection(E)), actor_idx) || return false\n\n      # Allow custom precondition logic\n      actor_precondition(evt, physical)\n  end\n\n  # Subtype must implement this\n  actor_precondition(evt::ActorEvent, physical) =\n      error(\"Must implement actor_precondition for $(typeof(evt))\")\n\n  # Generic generators for any ActorEvent\n  function generators(::Type{E}) where E <: ActorEvent{T} where T\n      collection = actor_collection(E)\n      state_field = actor_state_field(E)\n\n      return [\n          EventGenerator(\n              ToPlace,\n              [collection, â„¤, state_field],\n              function (f::Function, physical, actor)\n                  evt = try_create_event(E, actor, physical)\n                  !isnothing(evt) && f(evt)\n              end\n          )\n      ]\n  end\n\n  # Helper to create event if valid\n  try_create_event(::Type{E}, actor_idx, physical) where E <: ActorEvent = E(actor_idx)\n\n  # Generic enable with rate lookup\n  function enable(evt::E, sampler, physical, when, rng) where E <: ActorEvent\n      rate_dist = get_rate_distribution(evt, physical)\n      enable_time_args = get_enable_times(evt, physical, when)\n      enable!(sampler, clock_key(evt), rate_dist, enable_time_args..., rng)\n  end\n\n  # Default reenable delegates to enable\n  function reenable(evt::E, sampler, physical, first_enabled, curtime, rng) where E <: ActorEvent\n      rate_dist = get_rate_distribution(evt, physical)\n      reenable_time_args = get_reenable_times(evt, physical, first_enabled, curtime)\n      enable!(sampler, clock_key(evt), rate_dist, reenable_time_args..., rng)\n  end\n\n  # Subtype must implement rate lookup\n  get_rate_distribution(evt::ActorEvent, physical) =\n      error(\"Must implement get_rate_distribution for $(typeof(evt))\")\n\n  # Default time arguments\n  get_enable_times(evt::ActorEvent, physical, when) = (when, when)\n  get_reenable_times(evt::ActorEvent, physical, first_enabled, curtime) = (first_enabled, curtime)","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"And what it does to the simulation code:","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":" struct Break <: ActorEvent{IndividualState}\n      actor_idx::Int\n  end\n\n  # Only need to specify unique behavior\n  actor_precondition(evt::Break, physical) =\n      physical.actors[evt.actor_idx].state == working\n\n  get_rate_distribution(evt::Break, physical) =\n      physical.params[evt.actor_idx].fail_dist\n\n  # Custom time calculation for non-memoryless distributions\n  get_enable_times(evt::Break, physical, when) =\n      (when - physical.actors[evt.actor_idx].work_age, when)\n\n  function fire!(evt::Break, physical, when, rng)\n      physical.actors[evt.actor_idx].state = broken\n      started_work = physical.actors[evt.actor_idx].started_working_time\n      physical.actors[evt.actor_idx].work_age += when - started_work\n  end\n\n  # EndDay is even simpler\n  struct EndDay <: ActorEvent{IndividualState}\n      actor_idx::Int\n  end\n\n  actor_precondition(evt::EndDay, physical) =\n      physical.actors[evt.actor_idx].state == working\n\n  get_rate_distribution(evt::EndDay, physical) =\n      physical.params[evt.actor_idx].done_dist\n\n  function fire!(evt::EndDay, physical, when, rng)\n      physical.actors[evt.actor_idx].state = ready\n      started_work = physical.actors[evt.actor_idx].started_working_time\n      physical.actors[evt.actor_idx].work_age += when - started_work\n  end\n\n  # Repair\n  struct Repair <: ActorEvent{IndividualState}\n      actor_idx::Int\n  end\n\n  actor_precondition(evt::Repair, physical) =\n      physical.actors[evt.actor_idx].state == broken\n\n  get_rate_distribution(evt::Repair, physical) =\n      physical.params[evt.actor_idx].repair_dist\n\n  function fire!(evt::Repair, physical, when, rng)\n      physical.actors[evt.actor_idx].state = ready\n      physical.actors[evt.actor_idx].work_age = 0.0\n  end","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#SeeSign.BoardGeometry","page":"Reference","title":"SeeSign.BoardGeometry","text":"BoardGeometry encapsulates the 2D structure of a board while exposing only single-integer linear indices in its API. All 2D logic is handled internally.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SeeSign.DepNetNaive","page":"Reference","title":"SeeSign.DepNetNaive","text":"For testing, we make an equivalent version of the dependency network but this one uses a very different internal structure, an edge list.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SeeSign.DependencyNetwork","page":"Reference","title":"SeeSign.DependencyNetwork","text":"This is a multi-graph from places to events. It is a multi-graph because there can be two kinds of edges from the same place to the same event: an enabling edge and a rate edge. The graph is mutable, too, so you can add and remove events which adds and removes edges from the graph.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SeeSign.EventGenerator","page":"Reference","title":"SeeSign.EventGenerator","text":"EventGenerator{TransitionType}(matchstr, generator::Function)\n\nWhen an event fires, it changes the physical state. The simulation observes which parts of the physical state changed and sends those parts to this EventGenerator. The EventGenerator is a rule that matches changes to the physical state and creates SimEvent that act on that physical state.\n\nThe matchstr is a list of symbols (array_name, â„¤, struct_member). The â„¤ represents the integer index within the array. For instance, if we simulated chess, it might be (:board, â„¤, :piece).\n\nThe generator is a callback that the simulation uses to determine which events need to be enabled given recent changes to the state of the board. Its signature is:\n\n    callback_function(f::Function, physical_state, indices...)\n\nHere the indices are the integer index that matches the â„¤ above. This callback function should look at the physical state and call f(transition) where transition is an instance of SimEvent.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SeeSign.InitializeEvent","page":"Reference","title":"SeeSign.InitializeEvent","text":"InitializeEvent is a concrete transition type that represents the first event in the system, initialization.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SeeSign.PhysicalState","page":"Reference","title":"SeeSign.PhysicalState","text":"PhysicalState is an abstract type from which to inherit the state of a simulation. A PhysicalState should put all mutable values, the values upon which events depend, into TrackedVector objects. For instance:\n\n@tracked_struct Square begin\n    occupant::Int\n    resistance::Float64\nend\n\n\n# Everything we know about an agent.\n@tracked_struct Agent begin\n    health::Health\n    loc::CartesianIndex{2}\nend\n\nmutable struct BoardState <: PhysicalState\n    board::TrackedVector{Square}\n    agent::TrackedVector{Agent}\nend\n\nThe PhysicalState may contain other properties, but those defined with TrackedVectors are used to compute the next event in the simulation.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SeeSign.SimEvent","page":"Reference","title":"SeeSign.SimEvent","text":"SimEvent\n\nThis abstract type is the parent of all transitions in the system.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SeeSign.SimulationFSM-Union{Tuple{CK}, Tuple{Any, CompetingClocks.SSA{CK}, Any, Any}} where CK","page":"Reference","title":"SeeSign.SimulationFSM","text":"SimulationFSM(physical_state, sampler, trans_rules, seed; observer=nothing)\n\nCreate a simulation.\n\nThe physical_state is of type PhysicalState. The sampler is of type CompetingClocks.SSA. The trans_rules are a list of type SimEvent. The seed is an integer seed for a Xoshiro random number generator. The observer is a callback with the signature:\n\nobserver(physical, when::Float64, event::SimEvent, changed_places::Set{Tuple})\n\nThe changed_places argument is a set-like object with tuples that are keys that represent which places were changed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.StepArray","page":"Reference","title":"SeeSign.StepArray","text":"StepArray(arr)\n\nYou have an array and want to compare the current value with the previous value. This creates a double of the array so that memory use is optimized.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SeeSign.TrackedVector","page":"Reference","title":"SeeSign.TrackedVector","text":"TrackedVector{T}\n\nA vector that tracks access and changes to its elements.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.checkbounds-Tuple{Type{Bool}, SeeSign.BoardGeometry, Int64}","page":"Reference","title":"Base.checkbounds","text":"Check if a linear index is valid for this board.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.eachindex-Tuple{SeeSign.BoardGeometry}","page":"Reference","title":"Base.eachindex","text":"Iterate over all linear indices in row-major order.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.iterate","page":"Reference","title":"Base.iterate","text":"iterate(arr::StepArray, [state])\n\nEnables iteration over a StepArray, allowing it to be used in for loops and with other iteration functions like map, filter, etc.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.iterate-Tuple{SeeSign.BoardGeometry}","page":"Reference","title":"Base.iterate","text":"For iteration support.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.length-Tuple{SeeSign.BoardGeometry}","page":"Reference","title":"Base.length","text":"Get the total number of board positions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, SeeSign.BoardState}","page":"Reference","title":"Base.show","text":"Pretty print the board state.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.accept-Tuple{PhysicalState}","page":"Reference","title":"SeeSign.accept","text":"The arrays in a PhysicalState record that they have been modified. This function erases the record of modifications.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.allowed_infects-Tuple{Any}","page":"Reference","title":"SeeSign.allowed_infects","text":"For debugging, look at every allowed infection.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.allowed_moves-Tuple{Any}","page":"Reference","title":"SeeSign.allowed_moves","text":"For debugging, list every allowed movement transition.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.are_neighbors-Tuple{SeeSign.BoardGeometry, Int64, Int64}","page":"Reference","title":"SeeSign.are_neighbors","text":"Check if two positions are neighbors (adjacent horizontally or vertically).\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.ascii_to_array-Tuple{String}","page":"Reference","title":"SeeSign.ascii_to_array","text":"For testing, convert an ASCII image of a board into a 2D array of integers.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.capture_state_changes-Tuple{Function, Any}","page":"Reference","title":"SeeSign.capture_state_changes","text":"capture_state_changes(f::Function, physical_state)\n\nThe callback function f will modify the physical state. This function records which parts of the state were modified. The callback should have no arguments and may return a result.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.capture_state_reads-Tuple{Function, Any}","page":"Reference","title":"SeeSign.capture_state_reads","text":"capture_state_reads(f::Function, physical_state)\n\nThe callback function f will read the physical state. This function records which parts of the state were read. The callback should have no arguments and may return a result.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.changed-Tuple{PhysicalState}","page":"Reference","title":"SeeSign.changed","text":"Return a list of changed places in the physical state. A place for this state is a tuple of a symbol and the Cartesian index. The symbol is the name of the array within the PhysicalState.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.changed-Tuple{StepArray}","page":"Reference","title":"SeeSign.changed","text":"changed(arr::StepArray)\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.changed-Tuple{TrackedVector}","page":"Reference","title":"SeeSign.changed","text":"changed(obj)\n\nReturns the set of fields that have been modified.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.check_events-Tuple{Any}","page":"Reference","title":"SeeSign.check_events","text":"More debugging, check that all events are correct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.clock_key-Tuple{T} where T<:SimEvent","page":"Reference","title":"SeeSign.clock_key","text":"clock_key(::SimEvent)::Tuple\n\nAll SimEvent objects are immutable structs that represent events but don't carry any mutable state. A clock key is a tuple version of an event.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.deal_with_changes-Union{Tuple{CK}, Tuple{Sampler}, Tuple{State}, Tuple{SimulationFSM{State, Sampler, CK}, Any, Any}} where {State, Sampler, CK}","page":"Reference","title":"SeeSign.deal_with_changes","text":"deal_with_changes(sim::SimulationFSM)\n\nAn event changed the state. This function modifies events to respond to changes in state.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.dimensions-Tuple{SeeSign.BoardGeometry}","page":"Reference","title":"SeeSign.dimensions","text":"Get the dimensions of the board as (rows, cols).\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.direction_between-Tuple{SeeSign.BoardGeometry, Int64, Int64}","page":"Reference","title":"SeeSign.direction_between","text":"Get the direction from one position to its neighbor. Returns nothing if positions are not neighbors.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.enable-Tuple{MoveTransition, Any, Any}","page":"Reference","title":"SeeSign.enable","text":"This function decides the rate of the transition, but whether the transition is enabled was already decided by the @condition in the macro. That same @condition will be used to disable the transition.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.generators-Tuple{Type{<:SimEvent}}","page":"Reference","title":"SeeSign.generators","text":"generators(::Type{SimEvent})::Vector{EventGenerator}\n\nEvery transition in the simulation needs generators that notice changes to state or events fired and create the appropriate transitions. Implement a generators function as part of the interface of each transition.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.gotten-Tuple{TrackedVector}","page":"Reference","title":"SeeSign.gotten","text":"gotten(obj)\n\nReturns the set of fields that have been accessed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.initialize!-Tuple{Function, SimulationFSM}","page":"Reference","title":"SeeSign.initialize!","text":"Initialize the simulation. You could call it as a do-function. It is structured this way so that the simulation will record changes to the physical state.\n\n    initialize!(sim) do init_physical\n        initialize!(init_physical, agent_cnt, sim.rng)\n    end\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.isconsistent-Tuple{PhysicalState}","page":"Reference","title":"SeeSign.isconsistent","text":"isconsistent(physical_state)\n\nA simulation in debug mode will assert isconsistent(physical_state) is true. Override this to verify the physical state of your simulation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.isconsistent-Tuple{SeeSign.BoardState}","page":"Reference","title":"SeeSign.isconsistent","text":"Double-check the board state.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.isimmediate-Tuple{Type{<:SimEvent}}","page":"Reference","title":"SeeSign.isimmediate","text":"isimmediate(EventType)\n\nAn immediate event should return true for this function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.key_clock-Tuple{Tuple, Dict{Symbol, DataType}}","page":"Reference","title":"SeeSign.key_clock","text":"key_clock(key::Tuple, event_dict::Dict{Symbol, DataType})::SimEvent\n\nTakes a tuple of the form (:symbol, arg, arg) and a dictionary mapping symbols to struct types, and returns an instantiation of the struct named by :symbol. We pass in the list of datatypes because, if we didn't, then instantiation of a type from a symbol would need to search for the correct constructor in the correct module, and that would be both wrong and slow.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.move_agent-Tuple{Any, Any, Any}","page":"Reference","title":"SeeSign.move_agent","text":"Because the array of board squares is 1D but the board is 2D, there is translation when you move an agent.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.neighbor_in_direction-Tuple{SeeSign.BoardGeometry, Int64, SeeSign.Direction}","page":"Reference","title":"SeeSign.neighbor_in_direction","text":"Get the linear index of a neighbor in a specific direction. Returns nothing if the neighbor would be out of bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.neighbors-Tuple{SeeSign.BoardGeometry, Int64}","page":"Reference","title":"SeeSign.neighbors","text":"Get all linear indices of neighbors for a given position. Returns an iterator over valid neighbor positions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.over_tracked_physical_state-Union{Tuple{T}, Tuple{Function, T}} where T<:PhysicalState","page":"Reference","title":"SeeSign.over_tracked_physical_state","text":"Iterate over all tracked vectors in the physical state.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.previous_value-Tuple{StepArray, Vararg{Any}}","page":"Reference","title":"SeeSign.previous_value","text":"previous_value(arr::StepArray, i...)\n\nGet the previous value at index i before it was changed. Returns the current value if the element hasn't been changed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.random_position-Tuple{SeeSign.BoardGeometry, Any}","page":"Reference","title":"SeeSign.random_position","text":"Get a random valid position (linear index) on the board.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.reset_gotten!-Tuple{TrackedVector}","page":"Reference","title":"SeeSign.reset_gotten!","text":"reset_gotten!(obj)\n\nReset the tracking of accessed fields.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.reset_tracking!-Tuple{TrackedVector}","page":"Reference","title":"SeeSign.reset_tracking!","text":"reset_tracking!(obj)\n\nReset all tracking information.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.resetread-Tuple{PhysicalState}","page":"Reference","title":"SeeSign.resetread","text":"Return a list of changed places in the physical state. A place for this state is a tuple of a symbol and the Cartesian index. The symbol is the name of the array within the PhysicalState.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.run-Tuple{SimulationFSM, Any, Any}","page":"Reference","title":"SeeSign.run","text":"run(simulation, initializer, stop_condition)\n\nGiven a simulation, this initializes the physical state and generates a trajectory from the simulation until the stop condition is met. The initializer is a function whose argument is a physical state and returns nothing. The stop condition is a function with the signature:\n\nstop_condition(physical_state, step_idx, event::SimEvent, when)::Bool\n\nThe event and when passed into the stop condition are the event and time that are about to fire but have not yet fired. This lets you enforce a stopping time that is between events.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.track_assignments-Tuple{Function}","page":"Reference","title":"SeeSign.track_assignments","text":"track_assignments(f::Function)\n\nThis function takes a function f that returns nothing and creates a new function that returns a list of the indices of the elements that are assigned to in f.\n\nIt uses code introspection to analyze the function for array assignments without having to execute it with a proxy object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.valid_directions-Tuple{SeeSign.BoardGeometry, Int64}","page":"Reference","title":"SeeSign.valid_directions","text":"Get all valid directions from a given position. Returns an iterator over directions that lead to valid board positions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.wasread-Tuple{PhysicalState}","page":"Reference","title":"SeeSign.wasread","text":"Return a list of changed places in the physical state. A place for this state is a tuple of a symbol and the Cartesian index. The symbol is the name of the array within the PhysicalState.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.@tracked_struct-Tuple{Any, Any}","page":"Reference","title":"SeeSign.@tracked_struct","text":"@tracked_struct Name begin\n    field1::Type1\n    field2::Type2\n    # ...\nend\n\nCreates a struct that tracks when its fields are accessed or modified.\n\n\n\n\n\n","category":"macro"},{"location":"#SeeSign","page":"Home","title":"SeeSign","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SeeSign is a stochastic discrete event simulation framework that automatically tracks and manages complex interdependencies between events and state changes for high-performance scientific computing applications.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Exact stochastic simulation algorithm (SSA) for time-varying hazard rates.\nRule-based event generation.\nFine-grained coupling between state and events makes it easier to combine interacting behaviors in the same simulation.\nScientific computing focus.","category":"page"},{"location":"event_update/#How-Event-States-are-Updated","page":"Event Updates","title":"How Event States are Updated","text":"","category":"section"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The main loop of the framework for simulation will fire an event, look at changed places, and then update the events in the system. This turns is complicated, so let's discuss it here.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"An event has","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"A key which identifies its relationship to physical state.\nA set of places upon which its precondition depends.\nA set of places upon which its rate depends.\nA rate (distribution in time) that is set in the Sampler by the enable() function.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The same event key, when applied to a different physical state, may depend on different sets of places. This is not true for a traditional GSPN or GSMP, but it's how we think about events. For instance, a Move(agentidx, rightdirection) will depend on space to the right of the agent, but which space must be empty changes as the agent moves.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"A simulation has:","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"A set of enabled events.\nThe event that just fired.\nA set of states that were modified when the event fired.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The goal of the main loop of the simulation, once it has fired the event is to modify:","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The set of enabled events, by disabling those with failed preconditions or enabling those generated.\nThe set of places upon which precondition or rates depends for affected events.\nThe rate of events for which their place dependencies changed in value or for which the set of places has changed.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"Before and after this update, what can the states of an event be?","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"Disabled -> enabled and enabled -> disabled.\nSets of places can change.\nMaybe just the rate is called again.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The notion of re-enabling is a little tough. I will define that any time an event with the same clock key is enabled before and after firing, and the rate-depending places have changed, it is re-enabled. That's a firm definition. Rate-depending places can be a different set of places or they can have been written to. Either way.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"What sets of events do we have?","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The set of all events that depend on ANY changed places.\nThe set of those events whose preconditions still hold.\nThe set of those whose preconditions hold but they depend on different places.\nThe set of those whose rates depend on ANY changed places.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"Let's process the data this way, not an event at a time but a set of events at a time.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"A question: When rules generate new events, they don't need to create existing events. If we just discovered an event is disabled, that too can be excluded. My question is whether the set of all generated events intersected with the set of enabled events is contained in the set of affected events.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"(generated events) âˆ© (enabled events) âŠ† (affected event preconditions)","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The practical answer is that there aren't restrictions on event generation. The generator functions could generate lots of extra events, so there is no guarantee that those related to the recent modified places are all we will see.","category":"page"}]
}
