var documenterSearchIndex = {"docs":
[{"location":"getting_started/#Getting-Started-with-SeeSign.jl","page":"Getting Started","title":"Getting Started with SeeSign.jl","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This is an example of using Literate.jl to create executable documentation.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"SeeSign.jl is a simulation framework built on top of CompetingClocks.jl for event-driven simulations with dependency tracking.","category":"page"},{"location":"getting_started/#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"First, let's import the package:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using SeeSign","category":"page"},{"location":"getting_started/#Simple-Example","page":"Getting Started","title":"Simple Example","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Here's how you would set up a basic simulation: (This is just an example structure - you'll replace this with actual working code)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"println(\"This is a placeholder example for Literate.jl integration\")","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This is a placeholder example for Literate.jl integration\n","category":"page"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"As you develop more examples, you can add them as .jl files in the literate_src/ directory. They will be automatically converted to markdown and included in the documentation.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"plan/#Plan","page":"Plan","title":"Plan","text":"","category":"section"},{"location":"plan/#Current-Features","page":"Plan","title":"Current Features","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Rule-based events\nSampling methods\nDirac delta function times (for ODEs)\nDeterministic\nFerret out uses of Set that cause randomization.\nRe-enabling of events\nRules that depend on events instead of just states.\nMacro and struct for event(key)\nObservers on events\nObservers of state changes","category":"page"},{"location":"plan/#Immediate-Features","page":"Plan","title":"Immediate Features","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Immediate events","category":"page"},{"location":"plan/#Future-features","page":"Plan","title":"Future features","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Importance sampling\nPregeneration of all rule-based events.\nTransactional firing (for estimation of derivatives)\nHMC sampling from trajectories","category":"page"},{"location":"plan/#Example-Simulations","page":"Plan","title":"Example Simulations","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Movement and infection.\nMove, infect, age, birth.\nPolicy-driven movement.\nQueuing model.\nChemical equations.\nDrone search pattern with geometry.\nHMC for house-to-house infestation.\nJob shop problem.\nCars driving on a map.","category":"page"},{"location":"plan/#Example-Uses-of-Simulations","page":"Plan","title":"Example Uses of Simulations","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Hook into standard Julia analysis tools.\nSampling rare events.\nParameter fitting to world data.\nOptimization of parameters to minimize a goal function.\nHMC on trajectories to find a most likely event stream.\nPOMDP","category":"page"},{"location":"plan/#Performance-Questions","page":"Plan","title":"Performance Questions","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"How stable can I make the type system in the running simulation? It uses Events in places and tuples in others.\nThe TrackedEntry needs to be timed and gamed.\nCould the TrackedEntry be an N-dimensional array? Could each entry be an array? A dictionary?\nCan the main simulation look over the keys to determine types before it instantiates?\nThe depnet is absolutely wrong for the current main loop. It might be closer to right for another mainloop. Should try various implementations.\nMeasure performance with profiling. Look for the memory leaks.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#SeeSign.DepNetNaive","page":"Reference","title":"SeeSign.DepNetNaive","text":"For testing, we make an equivalent version of the dependency network but this one uses a very different internal structure, an edge list.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SeeSign.DependencyNetwork","page":"Reference","title":"SeeSign.DependencyNetwork","text":"This is a multi-graph from places to events. It is a multi-graph because there can be two kinds of edges from the same place to the same event: an enabling edge and a rate edge. The graph is mutable, too, so you can add and remove events which adds and removes edges from the graph.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SeeSign.EventEventGenerator","page":"Reference","title":"SeeSign.EventEventGenerator","text":"EventEventGenerator{TransitionType}(matchstr, generator::Function)\n\nThis generator reacts to the last event fired instead of EventGenerator which reacts to the last places modified. In this case, the matchstr is a vector with one entry, the symbol version of the transition type it matches. For a transition called MoveTransition it would be matchstr=[:MoveTransition].\n\nThe generator is a callback function whose signature is:\n\n    callback_function(f::Function, physical_state, event_members...)\n\nThis callback function is passed arguments that are the members of the instance of the transition it matched.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SeeSign.EventGenerator","page":"Reference","title":"SeeSign.EventGenerator","text":"EventGenerator{TransitionType}(matchstr, generator::Function)\n\nWhen an event fires, it changes the physical state. The simulation observes which parts of the physical state changed and sends those parts to this EventGenerator. The EventGenerator is a rule that matches changes to the physical state and creates SimEvent that act on that physical state.\n\nThe matchstr is a list of symbols (array_name, ℤ, struct_member). The ℤ represents the integer index within the array. For instance, if we simulated chess, it might be (:board, ℤ, :piece).\n\nThe generator is a callback that the simulation uses to determine which events need to be enabled given recent changes to the state of the board. Its signature is:\n\n    callback_function(f::Function, physical_state, indices...)\n\nHere the indices are the integer index that matches the ℤ above. This callback function should look at the physical state and call f(transition) where transition is an instance of SimEvent.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SeeSign.InitializeEvent","page":"Reference","title":"SeeSign.InitializeEvent","text":"InitializeEvent is a concrete transition type that represents the first event in the system, initialization.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SeeSign.PhysicalState","page":"Reference","title":"SeeSign.PhysicalState","text":"PhysicalState is an abstract type from which to inherit the state of a simulation. A PhysicalState should put all mutable values, the values upon which events depend, into TrackedVector objects. For instance:\n\n@tracked_struct Square begin\n    occupant::Int\n    resistance::Float64\nend\n\n\n# Everything we know about an agent.\n@tracked_struct Agent begin\n    health::Health\n    loc::CartesianIndex{2}\nend\n\nmutable struct BoardState <: PhysicalState\n    board::TrackedVector{Square}\n    agent::TrackedVector{Agent}\nend\n\nThe PhysicalState may contain other properties, but those defined with TrackedVectors are used to compute the next event in the simulation.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SeeSign.SimEvent","page":"Reference","title":"SeeSign.SimEvent","text":"SimEvent\n\nThis abstract type is the parent of all transitions in the system.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SeeSign.StepArray","page":"Reference","title":"SeeSign.StepArray","text":"StepArray(arr)\n\nYou have an array and want to compare the current value with the previous value. This creates a double of the array so that memory use is optimized.\n\n\n\n\n\n","category":"type"},{"location":"reference/#SeeSign.TrackedVector","page":"Reference","title":"SeeSign.TrackedVector","text":"TrackedVector{T}\n\nA vector that tracks access and changes to its elements.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.iterate","page":"Reference","title":"Base.iterate","text":"iterate(arr::StepArray, [state])\n\nEnables iteration over a StepArray, allowing it to be used in for loops and with other iteration functions like map, filter, etc.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.show-Tuple{IO, SeeSign.BoardState}","page":"Reference","title":"Base.show","text":"Pretty print the board state.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.accept-Tuple{PhysicalState}","page":"Reference","title":"SeeSign.accept","text":"The arrays in a PhysicalState record that they have been modified. This function erases the record of modifications.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.allowed_infects-Tuple{Any}","page":"Reference","title":"SeeSign.allowed_infects","text":"For debugging, look at every allowed infection.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.allowed_moves-Tuple{Any}","page":"Reference","title":"SeeSign.allowed_moves","text":"For debugging, list every allowed movement transition.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.ascii_to_array-Tuple{String}","page":"Reference","title":"SeeSign.ascii_to_array","text":"For testing, convert an ASCII image of a board into a 2D array of integers.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.capture_state_changes-Tuple{Function, Any}","page":"Reference","title":"SeeSign.capture_state_changes","text":"capture_state_changes(f::Function, physical_state)\n\nThe callback function f will modify the physical state. This function records which parts of the state were modified. The callback should have no arguments and may return a result.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.capture_state_reads-Tuple{Function, Any}","page":"Reference","title":"SeeSign.capture_state_reads","text":"capture_state_reads(f::Function, physical_state)\n\nThe callback function f will read the physical state. This function records which parts of the state were read. The callback should have no arguments and may return a result.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.changed-Tuple{PhysicalState}","page":"Reference","title":"SeeSign.changed","text":"Return a list of changed places in the physical state. A place for this state is a tuple of a symbol and the Cartesian index. The symbol is the name of the array within the PhysicalState.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.changed-Tuple{StepArray}","page":"Reference","title":"SeeSign.changed","text":"changed(arr::StepArray)\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.changed-Tuple{TrackedVector}","page":"Reference","title":"SeeSign.changed","text":"changed(obj)\n\nReturns the set of fields that have been modified.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.check_events-Tuple{Any}","page":"Reference","title":"SeeSign.check_events","text":"More debugging, check that all events are correct.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.classify_transition_rules-Tuple{Any}","page":"Reference","title":"SeeSign.classify_transition_rules","text":"SimulationFSM(physical_state, sampler, trans_rules, seed; observer=nothing)\n\nCreate a simulation.\n\nThe physical_state is of type PhysicalState. The sampler is of type CompetingClocks.SSA. The trans_rules are a list of type SimEvent. The seed is an integer seed for a Xoshiro random number generator. The observer is a callback with the signature:\n\nobserver(physical, when::Float64, event::SimEvent, changed_places::Set{Tuple})\n\nThe changed_places argument is a set-like object with tuples that are keys that represent which places were changed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.clock_key-Tuple{T} where T<:SimEvent","page":"Reference","title":"SeeSign.clock_key","text":"clock_key(::SimEvent)::Tuple\n\nAll SimEvent objects are immutable structs that represent events but don't carry any mutable state. A clock key is a tuple version of an event.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.deal_with_changes-Union{Tuple{CK}, Tuple{Sampler}, Tuple{State}, Tuple{SeeSign.SimulationFSM{State, Sampler, CK}, Any, Any}} where {State, Sampler, CK}","page":"Reference","title":"SeeSign.deal_with_changes","text":"deal_with_changes(sim::SimulationFSM)\n\nAn event changed the state. This function modifies events to respond to changes in state.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.enable-Tuple{MoveTransition, Vararg{Any, 4}}","page":"Reference","title":"SeeSign.enable","text":"This function decides the rate of the transition, but whether the transition is enabled was already decided by the @condition in the macro. That same @condition will be used to disable the transition.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.generators-Tuple{Type{SimEvent}}","page":"Reference","title":"SeeSign.generators","text":"generators(::Type{SimEvent})::Vector{Union{EventGenerator,EventEventGenerator}}\n\nEvery transition in the simulation needs generators that notice changes to state or events fired and create the appropriate transitions. Implement a generators function as part of the interface of each transition.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.gotten-Tuple{TrackedVector}","page":"Reference","title":"SeeSign.gotten","text":"gotten(obj)\n\nReturns the set of fields that have been accessed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.initialize!-Tuple{Function, SeeSign.SimulationFSM}","page":"Reference","title":"SeeSign.initialize!","text":"Initialize the simulation. You could call it as a do-function. It is structured this way so that the simulation will record changes to the physical state.\n\n    initialize!(sim) do init_physical\n        initialize!(init_physical, agent_cnt, sim.rng)\n    end\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.isconsistent-Tuple{PhysicalState}","page":"Reference","title":"SeeSign.isconsistent","text":"isconsistent(physical_state)\n\nA simulation in debug mode will assert isconsistent(physical_state) is true. Override this to verify the physical state of your simulation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.isconsistent-Tuple{SeeSign.BoardState}","page":"Reference","title":"SeeSign.isconsistent","text":"Double-check the board state.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.key_clock-Tuple{Tuple, Dict{Symbol, DataType}}","page":"Reference","title":"SeeSign.key_clock","text":"key_clock(key::Tuple, event_dict::Dict{Symbol, DataType})::SimEvent\n\nTakes a tuple of the form (:symbol, arg, arg) and a dictionary mapping symbols to struct types, and returns an instantiation of the struct named by :symbol. We pass in the list of datatypes because, if we didn't, then instantiation of a type from a symbol would need to search for the correct constructor in the correct module, and that would be both wrong and slow.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.move_agent-Tuple{Any, Any, Any}","page":"Reference","title":"SeeSign.move_agent","text":"Because the array of board squares is 1D but the board is 2D, there is translation when you move an agent.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.neighbor_lin-Tuple{Any, Any}","page":"Reference","title":"SeeSign.neighbor_lin","text":"Given the integer index into the linear board vector, return an iterator over the linear indices of neighbors that are in bounds.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.over_tracked_physical_state-Union{Tuple{T}, Tuple{Function, T}} where T<:PhysicalState","page":"Reference","title":"SeeSign.over_tracked_physical_state","text":"Iterate over all tracked vectors in the physical state.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.previous_value-Tuple{StepArray, Vararg{Any}}","page":"Reference","title":"SeeSign.previous_value","text":"previous_value(arr::StepArray, i...)\n\nGet the previous value at index i before it was changed. Returns the current value if the element hasn't been changed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.reset_gotten!-Tuple{TrackedVector}","page":"Reference","title":"SeeSign.reset_gotten!","text":"reset_gotten!(obj)\n\nReset the tracking of accessed fields.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.reset_tracking!-Tuple{TrackedVector}","page":"Reference","title":"SeeSign.reset_tracking!","text":"reset_tracking!(obj)\n\nReset all tracking information.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.resetread-Tuple{PhysicalState}","page":"Reference","title":"SeeSign.resetread","text":"Return a list of changed places in the physical state. A place for this state is a tuple of a symbol and the Cartesian index. The symbol is the name of the array within the PhysicalState.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.run-Tuple{SeeSign.SimulationFSM, Any, Any}","page":"Reference","title":"SeeSign.run","text":"run(simulation, initializer, stop_condition)\n\nGiven a simulation, this initializes the physical state and generates a trajectory from the simulation until the stop condition is met. The initializer is a function whose argument is a physical state and returns nothing. The stop condition is a function with the signature:\n\nstop_condition(physical_state, step_idx, event::SimEvent, when)::Bool\n\nThe event and when passed into the stop condition are the event and time that are about to fire but have not yet fired. This lets you enforce a stopping time that is between events.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.track_assignments-Tuple{Function}","page":"Reference","title":"SeeSign.track_assignments","text":"track_assignments(f::Function)\n\nThis function takes a function f that returns nothing and creates a new function that returns a list of the indices of the elements that are assigned to in f.\n\nIt uses code introspection to analyze the function for array assignments without having to execute it with a proxy object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.wasread-Tuple{PhysicalState}","page":"Reference","title":"SeeSign.wasread","text":"Return a list of changed places in the physical state. A place for this state is a tuple of a symbol and the Cartesian index. The symbol is the name of the array within the PhysicalState.\n\n\n\n\n\n","category":"method"},{"location":"reference/#SeeSign.@tracked_struct-Tuple{Any, Any}","page":"Reference","title":"SeeSign.@tracked_struct","text":"@tracked_struct Name begin\n    field1::Type1\n    field2::Type2\n    # ...\nend\n\nCreates a struct that tracks when its fields are accessed or modified.\n\n\n\n\n\n","category":"macro"},{"location":"#SeeSign","page":"Home","title":"SeeSign","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SeeSign is a stochastic discrete event simulation framework that automatically tracks and manages complex interdependencies between events and state changes for high-performance scientific computing applications.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Exact stochastic simulation algorithm (SSA) for time-varying hazard rates.\nRule-based event generation.\nFine-grained coupling between state and events makes it easier to combine interacting behaviors in the same simulation.\nScientific computing focus.","category":"page"},{"location":"event_update/#How-Event-States-are-Updated","page":"Event Updates","title":"How Event States are Updated","text":"","category":"section"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The main loop of the framework for simulation will fire an event, look at changed places, and then update the events in the system. This turns is complicated, so let's discuss it here.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"An event has","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"A key which identifies its relationship to physical state.\nA set of places upon which its precondition depends.\nA set of places upon which its rate depends.\nA rate (distribution in time) that is set in the Sampler by the enable() function.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The same event key, when applied to a different physical state, may depend on different sets of places. This is not true for a traditional GSPN or GSMP, but it's how we think about events. For instance, a Move(agentidx, rightdirection) will depend on space to the right of the agent, but which space must be empty changes as the agent moves.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"A simulation has:","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"A set of enabled events.\nThe event that just fired.\nA set of states that were modified when the event fired.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The goal of the main loop of the simulation, once it has fired the event is to modify:","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The set of enabled events, by disabling those with failed preconditions or enabling those generated.\nThe set of places upon which precondition or rates depends for affected events.\nThe rate of events for which their place dependencies changed in value or for which the set of places has changed.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"Before and after this update, what can the states of an event be?","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"Disabled -> enabled and enabled -> disabled.\nSets of places can change.\nMaybe just the rate is called again.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The notion of re-enabling is a little tough. I will define that any time an event with the same clock key is enabled before and after firing, and the rate-depending places have changed, it is re-enabled. That's a firm definition. Rate-depending places can be a different set of places or they can have been written to. Either way.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"What sets of events do we have?","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The set of all events that depend on ANY changed places.\nThe set of those events whose preconditions still hold.\nThe set of those whose preconditions hold but they depend on different places.\nThe set of those whose rates depend on ANY changed places.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"Let's process the data this way, not an event at a time but a set of events at a time.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"A question: When rules generate new events, they don't need to create existing events. If we just discovered an event is disabled, that too can be excluded. My question is whether the set of all generated events intersected with the set of enabled events is contained in the set of affected events.","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"(generated events) ∩ (enabled events) ⊆ (affected event preconditions)","category":"page"},{"location":"event_update/","page":"Event Updates","title":"Event Updates","text":"The practical answer is that there aren't restrictions on event generation. The generator functions could generate lots of extra events, so there is no guarantee that those related to the recent modified places are all we will see.","category":"page"}]
}
