var documenterSearchIndex = {"docs":
[{"location":"plan/#Plan","page":"Plan","title":"Plan","text":"","category":"section"},{"location":"plan/#Current-Features","page":"Plan","title":"Current Features","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Rule-based events\nSampling methods\nDirac delta function times (for ODEs)\nDeterministic\nFerret out uses of Set that cause randomization.\nRe-enabling of events","category":"page"},{"location":"plan/#Immediate-Features","page":"Plan","title":"Immediate Features","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Rules that depend on events instead of just states.\nMacro and struct for event(key)\nObservers on events\nObservers of state changes\nImmediate events","category":"page"},{"location":"plan/#Future-features","page":"Plan","title":"Future features","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Importance sampling\nPregeneration of all rule-based events.\nTransactional firing (for estimation of derivatives)\nHMC sampling from trajectories","category":"page"},{"location":"plan/#Examples","page":"Plan","title":"Examples","text":"","category":"section"},{"location":"plan/","page":"Plan","title":"Plan","text":"Movement and infection.\nMove, infect, age, birth.\nPolicy-driven movement.\nQueuing model.\nChemical equations.\nDrone search pattern with geometry.\nHMC for house-to-house infestation.\nJob shop problem.\nCars driving on a map.","category":"page"},{"location":"plan/","page":"Plan","title":"Plan","text":"","category":"page"},{"location":"#SeeSign","page":"Home","title":"SeeSign","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SeeSign.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#SeeSign.DepNetNaive","page":"Home","title":"SeeSign.DepNetNaive","text":"For testing, we make an equivalent version of the dependency network but this one uses a very different internal structure, an edge list.\n\n\n\n\n\n","category":"type"},{"location":"#SeeSign.DependencyNetwork","page":"Home","title":"SeeSign.DependencyNetwork","text":"This is a multi-graph from places to events. It is a multi-graph because there can be two kinds of edges from the same place to the same event: an enabling edge and a rate edge. The graph is mutable, too, so you can add and remove events which adds and removes edges from the graph.\n\n\n\n\n\n","category":"type"},{"location":"#SeeSign.StepArray","page":"Home","title":"SeeSign.StepArray","text":"StepArray(arr)\n\nYou have an array and want to compare the current value with the previous value. This creates a double of the array so that memory use is optimized.\n\n\n\n\n\n","category":"type"},{"location":"#SeeSign.TrackedVector","page":"Home","title":"SeeSign.TrackedVector","text":"TrackedVector{T}\n\nA vector that tracks access and changes to its elements.\n\n\n\n\n\n","category":"type"},{"location":"#Base.iterate","page":"Home","title":"Base.iterate","text":"iterate(arr::StepArray, [state])\n\nEnables iteration over a StepArray, allowing it to be used in for loops and with other iteration functions like map, filter, etc.\n\n\n\n\n\n","category":"function"},{"location":"#Base.show-Tuple{IO, SeeSign.BoardState}","page":"Home","title":"Base.show","text":"Pretty print the board state.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.accept-Tuple{PhysicalState}","page":"Home","title":"SeeSign.accept","text":"The arrays in a PhysicalState record that they have been modified. This function erases the record of modifications.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.allowed_infects-Tuple{Any}","page":"Home","title":"SeeSign.allowed_infects","text":"For debugging, look at every allowed infection.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.allowed_moves-Tuple{Any}","page":"Home","title":"SeeSign.allowed_moves","text":"For debugging, list every allowed movement transition.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.ascii_to_array-Tuple{String}","page":"Home","title":"SeeSign.ascii_to_array","text":"For testing, convert an ASCII image of a board into a 2D array of integers.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.changed-Tuple{PhysicalState}","page":"Home","title":"SeeSign.changed","text":"Return a list of changed places in the physical state. A place for this state is a tuple of a symbol and the Cartesian index. The symbol is the name of the array within the PhysicalState.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.changed-Tuple{StepArray}","page":"Home","title":"SeeSign.changed","text":"changed(arr::StepArray)\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.changed-Tuple{TrackedVector}","page":"Home","title":"SeeSign.changed","text":"changed(obj)\n\nReturns the set of fields that have been modified.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.check_events-Tuple{Any}","page":"Home","title":"SeeSign.check_events","text":"More debugging, check that all events are correct.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.deal_with_changes-Union{Tuple{SeeSign.SimulationFSM{State, Sampler, CK}}, Tuple{CK}, Tuple{Sampler}, Tuple{State}} where {State, Sampler, CK}","page":"Home","title":"SeeSign.deal_with_changes","text":"deal_with_changes(sim::SimulationFSM)\n\nAn event changed the state. This function modifies events to respond to changes in state.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.enable-Tuple{MoveTransition, Vararg{Any, 4}}","page":"Home","title":"SeeSign.enable","text":"This function decides the rate of the transition, but whether the transition is enabled was already decided by the @condition in the macro. That same @condition will be used to disable the transition.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.gotten-Tuple{TrackedVector}","page":"Home","title":"SeeSign.gotten","text":"gotten(obj)\n\nReturns the set of fields that have been accessed.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.isconsistent-Tuple{PhysicalState}","page":"Home","title":"SeeSign.isconsistent","text":"Used for debugging.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.isconsistent-Tuple{SeeSign.BoardState}","page":"Home","title":"SeeSign.isconsistent","text":"Double-check the board state.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.move_agent-Tuple{Any, Any, Any}","page":"Home","title":"SeeSign.move_agent","text":"Because the array of board squares is 1D but the board is 2D, there is translation when you move an agent.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.neighbor_lin-Tuple{Any, Any}","page":"Home","title":"SeeSign.neighbor_lin","text":"Given the integer index into the linear board vector, return an iterator over the linear indices of neighbors that are in bounds.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.over_tracked_physical_state-Union{Tuple{T}, Tuple{Function, T}} where T<:PhysicalState","page":"Home","title":"SeeSign.over_tracked_physical_state","text":"Iterate over all tracked vectors in the physical state.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.previous_value-Tuple{StepArray, Vararg{Any}}","page":"Home","title":"SeeSign.previous_value","text":"previous_value(arr::StepArray, i...)\n\nGet the previous value at index i before it was changed. Returns the current value if the element hasn't been changed.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.reset_gotten!-Tuple{TrackedVector}","page":"Home","title":"SeeSign.reset_gotten!","text":"reset_gotten!(obj)\n\nReset the tracking of accessed fields.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.reset_tracking!-Tuple{TrackedVector}","page":"Home","title":"SeeSign.reset_tracking!","text":"reset_tracking!(obj)\n\nReset all tracking information.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.resetread-Tuple{PhysicalState}","page":"Home","title":"SeeSign.resetread","text":"Return a list of changed places in the physical state. A place for this state is a tuple of a symbol and the Cartesian index. The symbol is the name of the array within the PhysicalState.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.track_assignments-Tuple{Function}","page":"Home","title":"SeeSign.track_assignments","text":"track_assignments(f::Function)\n\nThis function takes a function f that returns nothing and creates a new function that returns a list of the indices of the elements that are assigned to in f.\n\nIt uses code introspection to analyze the function for array assignments without having to execute it with a proxy object.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.wasread-Tuple{PhysicalState}","page":"Home","title":"SeeSign.wasread","text":"Return a list of changed places in the physical state. A place for this state is a tuple of a symbol and the Cartesian index. The symbol is the name of the array within the PhysicalState.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.@tracked_struct-Tuple{Any, Any}","page":"Home","title":"SeeSign.@tracked_struct","text":"@tracked_struct Name begin\n    field1::Type1\n    field2::Type2\n    # ...\nend\n\nCreates a struct that tracks when its fields are accessed or modified.\n\n\n\n\n\n","category":"macro"},{"location":"event_update/#How-Event-States-are-Updated","page":"How Event States are Updated","title":"How Event States are Updated","text":"","category":"section"},{"location":"event_update/","page":"How Event States are Updated","title":"How Event States are Updated","text":"The main loop of the framework for simulation will fire an event, look at changed places, and then update the events in the system. This turns is complicated, so let's discuss it here.","category":"page"},{"location":"event_update/","page":"How Event States are Updated","title":"How Event States are Updated","text":"An event has","category":"page"},{"location":"event_update/","page":"How Event States are Updated","title":"How Event States are Updated","text":"A key which identifies its relationship to physical state.\nA set of places upon which its precondition depends.\nA set of places upon which its rate depends.\nA rate (distribution in time) that is set in the Sampler by the enable() function.","category":"page"},{"location":"event_update/","page":"How Event States are Updated","title":"How Event States are Updated","text":"The same event key, when applied to a different physical state, may depend on different sets of places. This is not true for a traditional GSPN or GSMP, but it's how we think about events. For instance, a Move(agentidx, rightdirection) will depend on space to the right of the agent, but which space must be empty changes as the agent moves.","category":"page"},{"location":"event_update/","page":"How Event States are Updated","title":"How Event States are Updated","text":"A simulation has:","category":"page"},{"location":"event_update/","page":"How Event States are Updated","title":"How Event States are Updated","text":"A set of enabled events.\nThe event that just fired.\nA set of states that were modified when the event fired.","category":"page"},{"location":"event_update/","page":"How Event States are Updated","title":"How Event States are Updated","text":"The goal of the main loop of the simulation, once it has fired the event is to modify:","category":"page"},{"location":"event_update/","page":"How Event States are Updated","title":"How Event States are Updated","text":"The set of enabled events, by disabling those with failed preconditions or enabling those generated.\nThe set of places upon which precondition or rates depends for affected events.\nThe rate of events for which their place dependencies changed in value or for which the set of places has changed.","category":"page"},{"location":"event_update/","page":"How Event States are Updated","title":"How Event States are Updated","text":"Before and after this update, what can the states of an event be?","category":"page"},{"location":"event_update/","page":"How Event States are Updated","title":"How Event States are Updated","text":"Disabled -> enabled and enabled -> disabled.\nSets of places can change.\nMaybe just the rate is called again.","category":"page"},{"location":"event_update/","page":"How Event States are Updated","title":"How Event States are Updated","text":"The notion of re-enabling is a little tough. I will define that any time an event with the same clock key is enabled before and after firing, and the rate-depending places have changed, it is re-enabled. That's a firm definition. Rate-depending places can be a different set of places or they can have been written to. Either way.","category":"page"},{"location":"event_update/","page":"How Event States are Updated","title":"How Event States are Updated","text":"What sets of events do we have?","category":"page"},{"location":"event_update/","page":"How Event States are Updated","title":"How Event States are Updated","text":"The set of all events that depend on ANY changed places.\nThe set of those events whose preconditions still hold.\nThe set of those whose preconditions hold but they depend on different places.\nThe set of those whose rates depend on ANY changed places.","category":"page"},{"location":"event_update/","page":"How Event States are Updated","title":"How Event States are Updated","text":"Let's process the data this way, not an event at a time but a set of events at a time.","category":"page"},{"location":"event_update/","page":"How Event States are Updated","title":"How Event States are Updated","text":"A question: When rules generate new events, they don't need to create existing events. If we just discovered an event is disabled, that too can be excluded. My question is whether the set of all generated events intersected with the set of enabled events is contained in the set of affected events.","category":"page"},{"location":"event_update/","page":"How Event States are Updated","title":"How Event States are Updated","text":"(generated events) ∩ (enabled events) ⊆ (affected event preconditions)","category":"page"},{"location":"event_update/","page":"How Event States are Updated","title":"How Event States are Updated","text":"The practical answer is that there aren't restrictions on event generation. The generator functions could generate lots of extra events, so there is no guarantee that those related to the recent modified places are all we will see.","category":"page"}]
}
