var documenterSearchIndex = {"docs":
[{"location":"#SeeSign","page":"Home","title":"SeeSign","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SeeSign.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#SeeSign.DependencyNetwork","page":"Home","title":"SeeSign.DependencyNetwork","text":"This is a multi-graph from places to events. It is a multi-graph because there can be two kinds of edges from the same place to the same event: an enabling edge and a rate edge. The graph is mutable, too, so you can add and remove events which adds and removes edges from the graph.\n\n\n\n\n\n","category":"type"},{"location":"#SeeSign.StepArray","page":"Home","title":"SeeSign.StepArray","text":"StepArray(arr)\n\nYou have an array and want to compare the current value with the previous value. This creates a double of the array so that memory use is optimized.\n\n\n\n\n\n","category":"type"},{"location":"#SeeSign.TrackedVector","page":"Home","title":"SeeSign.TrackedVector","text":"TrackedVector{T}\n\nA vector that tracks access and changes to its elements.\n\n\n\n\n\n","category":"type"},{"location":"#Base.iterate","page":"Home","title":"Base.iterate","text":"iterate(arr::StepArray, [state])\n\nEnables iteration over a StepArray, allowing it to be used in for loops and with other iteration functions like map, filter, etc.\n\n\n\n\n\n","category":"function"},{"location":"#SeeSign.accept-Tuple{SeeSign.PhysicalState}","page":"Home","title":"SeeSign.accept","text":"The arrays in a PhysicalState record that they have been modified. This function erases the record of modifications.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.change-Tuple{Any}","page":"Home","title":"SeeSign.change","text":"change(obj)\n\nReturns the set of fields that have been modified. Alias for changed().\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.changed-Tuple{SeeSign.PhysicalState}","page":"Home","title":"SeeSign.changed","text":"Return a list of changed places in the physical state. A place for this state is a tuple of a symbol and the Cartesian index. The symbol is the name of the array within the PhysicalState.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.changed-Tuple{StepArray}","page":"Home","title":"SeeSign.changed","text":"changed(arr::StepArray)\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.changed-Tuple{TrackedVector}","page":"Home","title":"SeeSign.changed","text":"changed(obj)\n\nReturns the set of fields that have been modified.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.deal_with_changes-Union{Tuple{SeeSign.SimulationFSM{State, Sampler, CK}}, Tuple{CK}, Tuple{Sampler}, Tuple{State}} where {State, Sampler, CK}","page":"Home","title":"SeeSign.deal_with_changes","text":"deal_with_changes(sim::SimulationFSM)\n\nAn event changed the state. This function modifies events to respond to changes in state.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.gotten-Tuple{TrackedVector}","page":"Home","title":"SeeSign.gotten","text":"gotten(obj)\n\nReturns the set of fields that have been accessed.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.isconsistent-Tuple{SeeSign.PhysicalState}","page":"Home","title":"SeeSign.isconsistent","text":"Used for debugging.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.over_tracked_physical_state-Union{Tuple{T}, Tuple{Function, T}} where T<:SeeSign.PhysicalState","page":"Home","title":"SeeSign.over_tracked_physical_state","text":"Iterate over all tracked vectors in the physical state.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.previous_value-Tuple{StepArray, Vararg{Any}}","page":"Home","title":"SeeSign.previous_value","text":"previous_value(arr::StepArray, i...)\n\nGet the previous value at index i before it was changed. Returns the current value if the element hasn't been changed.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.reset_gotten!-Tuple{TrackedVector}","page":"Home","title":"SeeSign.reset_gotten!","text":"reset_gotten!(obj)\n\nReset the tracking of accessed fields.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.reset_tracking!-Tuple{TrackedVector}","page":"Home","title":"SeeSign.reset_tracking!","text":"reset_tracking!(obj)\n\nReset all tracking information.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.resetread-Tuple{SeeSign.PhysicalState}","page":"Home","title":"SeeSign.resetread","text":"Return a list of changed places in the physical state. A place for this state is a tuple of a symbol and the Cartesian index. The symbol is the name of the array within the PhysicalState.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.toencroach_generate_event-Tuple{Any, Any, Any}","page":"Home","title":"SeeSign.toencroach_generate_event","text":"Let's add a process for susceptible-infected. There are two cases to handle that have to do with movement.\n\nSusceptible moves next to infected.\nInfected moves next to susceptible.\n\n@react toencroach(physical) begin\n    @match changed(physical.agent[who].loc)\n    @generate direction ∈ keys(DirectionDelta)\n    @if begin\n            agent = physical.board[who].occupant\n            if agent > 0\n                result, susceptible, infectious = sick_movement(physical, agent, direction)\n                result\n            else\n                false\n            end\n        end\n    @action InfectTransition(infectious, susceptible)\nend\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.tomove_generate_event-Tuple{Any, Any, Any}","page":"Home","title":"SeeSign.tomove_generate_event","text":"A dynamic generator of events. This looks at a changed place in the  physical state and generates clock keys for events that could depend on that place.\n\n@react tomove(physical) begin\n    @match changed(physical.board[loc].occupant)\n    @generate direction ∈ keys(DirectionDelta)\n    @if begin\n            agent = physical.board[loc].occupant\n            loc_cartesian = physical.board_dim[loc]\n            new_loc = loc_cartesian + DirectionDelta[direction]\n            if checkbounds(Bool, physical.board_dim, new_loc)\n                new_loc_linear = LinearIndices(physical.board_dim)[new_loc]\n                agent > 0 &&\n                physical.board[new_loc_linear].occupant == 0\n            else\n                false\n            end\n        end\n    @action MoveTransition(agent, direction)\nend\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.tosickfriend_generate_event-Tuple{Any, Any, Any}","page":"Home","title":"SeeSign.tosickfriend_generate_event","text":"This is the case where a neighbor didn't move but became infected in place and can therefore now infect a neighbor.\n\n@react tosickfriend(physical) begin\n    @match changed(physical.agent[who].health)\n    @generate direction ∈ keys(DirectionDelta)\n    @if begin\n            health = physical.agent[who].health\n            neighbor_cart_loc = physical.agent[who].loc + DirectionDelta[direction]\n            if health == Sick && checkbounds(Bool, physical.board_dim, neighbor_cart_loc)\n                neighbor_loc_linear = LinearIndices(physical.board_dim)[neighbor_cart_loc]\n                neighbor = physical.board[neighbor_loc_linear].occupant\n                if neighbor > 0\n                    neighbor_health = physical.agent[neighbor].health\n                    # If the neighbor is susceptible, then it can become infected.\n                    neighbor_health == Healthy\n                else\n                    false\n                end\n            else\n                false\n            end\n        end\n    @action InfectTransition(who, neighbor)\nend\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.tospace_generate_event-Tuple{Any, Any, Any}","page":"Home","title":"SeeSign.tospace_generate_event","text":"This is the case where a neighbor couldn't move because it was blocked but now the space is free and it can move.\n\n@react tomove(physical) begin\n    @match changed(physical.board[space].occupant)\n    @generate direction ∈ keys(DirectionDelta)\n    @if begin\n            neighbor = physical.board[space].occupant\n            loc_cartesian = physical.board_dim[space]\n            mover_loc = loc_cartesian + DirectionDelta[direction]\n            if neighbor == 0 && checkbounds(Bool, physical.board_dim, mover_loc)\n                mover_loc_linear = LinearIndices(physical.board_dim)[mover_loc]\n                mover = physical.board[mover_loc_linear].occupant\n                move_direction = DirectionOpposite[direction]\n                mover > 0\n            else\n                false\n            end\n        end\n    @action MoveTransition(mover, move_direction)\nend\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.track_assignments-Tuple{Function}","page":"Home","title":"SeeSign.track_assignments","text":"track_assignments(f::Function)\n\nThis function takes a function f that returns nothing and creates a new function that returns a list of the indices of the elements that are assigned to in f.\n\nIt uses code introspection to analyze the function for array assignments without having to execute it with a proxy object.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.wasread-Tuple{SeeSign.PhysicalState}","page":"Home","title":"SeeSign.wasread","text":"Return a list of changed places in the physical state. A place for this state is a tuple of a symbol and the Cartesian index. The symbol is the name of the array within the PhysicalState.\n\n\n\n\n\n","category":"method"},{"location":"#SeeSign.@tracked_struct-Tuple{Any, Any}","page":"Home","title":"SeeSign.@tracked_struct","text":"@tracked_struct Name begin\n    field1::Type1\n    field2::Type2\n    # ...\nend\n\nCreates a struct that tracks when its fields are accessed or modified.\n\n\n\n\n\n","category":"macro"}]
}
