
########

struct MoveTransition
    mover::Int
    direction::Direction
    MoveTransition(physical, mover, direction) = new(mover, direction)
end

# clock_key makes an immutable hash from a possibly-mutable struct for use in Dict.
clock_key(event::MoveTransition) = (:MoveTransition, event.mover, event.direction)

function precondition(::Type{MoveTransition}, physical, mover, direction)
    mover > 0 || return false
    neighbor_loc = physical.agent[mover].loc + direction
    checkbounds(Bool, physical.board_dim, neighbor_loc) || return false
    neighbor_lin = LinearIndices(physical.board)[neighbor_loc]
    physical.board[mover].occupant > 0 &&
        physical.board[neighbor_lin].occupant == 0
end


function move_move_gen(f::Function, physical, board_lin)
    mover = physical.board[board_lin].occupant
    for direction in DIRECTIONS
        f(physical, mover, direction)
    end
end


function move_change_gen(f::Function, physical, board_lin)
    li = LinearIndices(physical.board_dim)
    for direction in DIRECTIONS
        move_loc = physical.board_dim[board_lin] + direction
        if checkbounds(Bool, physical.board_dim, move_loc)
            move_lin = li[move_loc]
            mover = physical.board_dim[move_lin].occupant
            move_direction = DirectionOpposite[direction]
            f(physical, mover, move_direction)
        end
    end
end

generators(::Type{MoveTransition}) = [
    EventGenerator{MoveTransition}([:board, Z⁺, :occupant], move_move_gen),
    EventGenerator{MoveTransition}([:board, Z⁺, :occupant], move_change_gen)
    ]



# function tomove_generate_event(physical, place_key, existing_events)
#     # In this function, a variabled name that starts with `sym_` will be
#     # generated by a macro, so it will be replaced with a unique name.

#     # Select based on the place key.
#     sym_array_name, sym_index_value, sym_struct_value... = place_key
#     if sym_array_name != :board || sym_struct_value != (:occupant,)
#         return nothing
#     end
#     # loc comes from matching the place key.
#     loc = sym_index_value

#     # Not sure where to define this type BoardTransition.
#     sym_create = BoardTransition[]
#     sym_depends = Set{PlaceKey}[]
#     sym_enabled = Function[]

#     # Create the set of generative elements. We will do a for-loop over
#     # these, but we need to insert code into the for-loop.
#     # The top of the for-loop comes from the @generate macro.
#     for direction ∈ keys(DirectionDelta)
#         # Inserted code at beginning.
#         resetread(physical)

#         # Now comes the code block from @condition. This time the code block
#         # is in a BEGIN-END block and NOT a closure because we need any
#         # variables defined here to be found by the code from the @action macro.
#         sym_enable_clock = begin
#             agent = physical.board[loc].occupant
#             loc_cartesian = physical.board_dim[loc]
#             new_loc = loc_cartesian + DirectionDelta[direction]
#             if checkbounds(Bool, physical.board_dim, new_loc)
#                 new_loc_linear = LinearIndices(physical.board_dim)[new_loc]
#                 agent > 0 &&
#                 physical.board[new_loc_linear].occupant == 0
#             else
#                 false
#             end
#         end

#         # Inserted code at ending.
#         if sym_enable_clock
#             input_places = wasread(physical)
            
#             # This constructor call comes from the @action macro.
#             transition = MoveTransition(agent, direction)

#             # This is the function from the @condition block again, but here
#             # it is a closure.
#             enable_func = let loc = sym_index_value, direction = direction
#                 function(physical)
#                     agent = physical.board[loc].occupant
#                     loc_cartesian = physical.board_dim[loc]
#                     new_loc = loc_cartesian + DirectionDelta[direction]
#                     if checkbounds(Bool, physical.board_dim, new_loc)
#                         new_loc_linear = LinearIndices(physical.board_dim)[new_loc]
#                         agent > 0 &&
#                         physical.board[new_loc_linear].occupant == 0
#                     else
#                         false
#                     end
#                 end
#             end

#             # Then back to the inserted code.
#             clock_key(transition) in existing_events && continue
#             # The point of this is to make a new transition.
#             push!(sym_create, transition)
#             # That transition depends on the input places just read during @condition.
#             push!(sym_depends, input_places)
#             push!(sym_enabled, enable_func)
#         end
#     end
#     if isempty(sym_create)
#         return nothing
#     else
#         return (create=sym_create, depends=sym_depends, enabled=sym_enabled)
#     end
# end


# function tospace_generate_event(physical, place_key, existing_events)
#     # In this function, a variabled name that starts with `sym_` will be
#     # generated by a macro, so it will be replaced with a unique name.

#     # Select based on the place key.
#     sym_array_name, sym_index_value, sym_struct_value... = place_key
#     if sym_array_name != :board || sym_struct_value != (:occupant,)
#         return nothing
#     end
#     # space comes from matching the place key.
#     space = sym_index_value

#     # Not sure where to define this type BoardTransition.
#     sym_create = BoardTransition[]
#     sym_depends = Set{PlaceKey}[]
#     sym_enabled = Function[]

#     # Create the set of generative elements. We will do a for-loop over
#     # these, but we need to insert code into the for-loop.
#     # The top of the for-loop comes from the @generate macro.
#     for direction ∈ keys(DirectionDelta)
#         # Inserted code at beginning.
#         resetread(physical)
#         # Now comes the code block from @condition. This time the code block
#         # is in a BEGIN-END block and NOT a closure because we need any
#         # variables defined here to be found by the code from the @action macro.
#         sym_enable_clock = begin
#             neighbor = physical.board[space].occupant
#             loc_cartesian = physical.board_dim[space]
#             mover_loc = loc_cartesian + DirectionDelta[direction]
#             if neighbor == 0 && checkbounds(Bool, physical.board_dim, mover_loc)
#                 mover_loc_linear = LinearIndices(physical.board_dim)[mover_loc]
#                 mover = physical.board[mover_loc_linear].occupant
#                 move_direction = DirectionOpposite[direction]
#                 mover > 0
#             else
#                 false
#             end
#         end

#         # Inserted code at ending.
#         if sym_enable_clock
#             input_places = wasread(physical)
            
#             # This constructor call comes from the @action macro.
#             transition = MoveTransition(mover, move_direction)

#             # This is the function from the @condition block again, but here
#             # it is a closure.
#             enable_func = let space = sym_index_value, direction = direction
#                 function(physical)
#                     neighbor = physical.board[space].occupant
#                     loc_cartesian = physical.board_dim[space]
#                     mover_loc = loc_cartesian + DirectionDelta[direction]
#                     if neighbor == 0 && checkbounds(Bool, physical.board_dim, mover_loc)
#                         mover_loc_linear = LinearIndices(physical.board_dim)[mover_loc]
#                         mover = physical.board[mover_loc_linear].occupant
#                         move_direction = DirectionOpposite[direction]
#                         mover > 0
#                     else
#                         false
#                     end
#                 end
#             end

#             # Then back to the inserted code.
#             clock_key(transition) in existing_events && continue
#             # The point of this is to make a new transition.
#             push!(sym_create, transition)
#             # That transition depends on the input places just read during @condition.
#             push!(sym_depends, input_places)
#             push!(sym_enabled, enable_func)
#         end
#     end
#     if isempty(sym_create)
#         return nothing
#     else
#         return (create=sym_create, depends=sym_depends, enabled=sym_enabled)
#     end
# end


# function toencroach_generate_event(physical, place_key, existing_events)
#     # In this function, a variabled name that starts with `sym_` will be
#     # generated by a macro, so it will be replaced with a unique name.

#     # Select based on the place key.
#     sym_array_name, sym_index_value, sym_struct_value... = place_key
#     if sym_array_name != :agent || sym_struct_value != (:loc,)
#         return nothing
#     end
#     # who comes from matching the place key.
#     who = sym_index_value

#     # Not sure where to define this type BoardTransition.
#     sym_create = BoardTransition[]
#     sym_depends = Set{PlaceKey}[]
#     sym_enabled = Function[]

#     # Create the set of generative elements. We will do a for-loop over
#     # these, but we need to insert code into the for-loop.
#     # The top of the for-loop comes from the @generate macro.
#     for direction in keys(DirectionDelta)
#         # Inserted code at beginning.
#         resetread(physical)

#         # Now comes the code block from @condition. This time the code block
#         # is in a BEGIN-END block and NOT a closure because we need any
#         # variables defined here to be found by the code from the @action macro.
#         sym_enable_clock = begin
#             result, susceptible, infectious = sick_movement(physical, who, direction)
#             result
#         end

#         # Inserted code at ending.
#         if sym_enable_clock
#             input_places = wasread(physical)
            
#             # This constructor call comes from the @action macro.
#             transition = InfectTransition(infectious, susceptible)

#             # This is the function from the @condition block again, but here
#             # it is a closure.
#             enable_func = let who = sym_index_value, direction = direction
#                 function(physical)
#                     result, susceptible, infectious = sick_movement(physical, who, direction)
#                     result
#                 end
#             end

#             # Then back to the inserted code.
#             clock_key(transition) in existing_events && continue
#             # The point of this is to make a new transition.
#             push!(sym_create, transition)
#             # That transition depends on the input places just read during @condition.
#             push!(sym_depends, input_places)
#             push!(sym_enabled, enable_func)
#         end
#     end
#     if isempty(sym_create)
#         return nothing
#     else
#         return (create=sym_create, depends=sym_depends, enabled=sym_enabled)
#     end
# end


# function tosickfriend_generate_event(physical, place_key, existing_events)
#     # In this function, a variabled name that starts with `sym_` will be
#     # generated by a macro, so it will be replaced with a unique name.

#     # Select based on the place key according to the @onevent macro.
#     sym_array_name, sym_index_value, sym_struct_value... = place_key
#     if sym_array_name != :agent || sym_struct_value != (:health,)
#         return nothing
#     end
#     # who comes from matching the place key.
#     who = sym_index_value

#     # Not sure where to define this type BoardTransition.
#     sym_create = BoardTransition[]
#     sym_depends = Set{PlaceKey}[]
#     sym_enabled = Function[]

#     # Create the set of generative elements. We will do a for-loop over
#     # these, but we need to insert code into the for-loop.
#     # The top of the for-loop comes from the @generate macro.
#     for direction in keys(DirectionDelta)
#         # Inserted code at beginning.
#         resetread(physical)

#         # Now comes the code block from @condition. This time the code block
#         # is in a BEGIN-END block and NOT a closure because we need any
#         # variables defined here to be found by the code from the @action macro.
#         sym_enable_clock = begin
#             health = physical.agent[who].health
#             neighbor_cart_loc = physical.agent[who].loc + DirectionDelta[direction]
#             if health == Sick && checkbounds(Bool, physical.board_dim, neighbor_cart_loc)
#                 neighbor_loc_linear = LinearIndices(physical.board_dim)[neighbor_cart_loc]
#                 neighbor = physical.board[neighbor_loc_linear].occupant
#                 if neighbor > 0
#                     neighbor_health = physical.agent[neighbor].health
#                     # If the neighbor is susceptible, then it can become infected.
#                     neighbor_health == Healthy
#                 else
#                     false
#                 end
#             else
#                 false
#             end
#         end

#         # Inserted code at ending.
#         if sym_enable_clock
#             input_places = wasread(physical)
            
#             # This constructor call comes from the @action macro.
#             transition = InfectTransition(who, neighbor)

#             # This is the function from the @condition block again, but here
#             # it is a closure.
#             enable_func = let who = sym_index_value, direction = direction
#                 function(physical)
#                     health = physical.agent[who].health
#                     neighbor_cart_loc = physical.agent[who].loc + DirectionDelta[direction]
#                     if health == Sick && checkbounds(Bool, physical.board_dim, neighbor_cart_loc)
#                         neighbor_loc_linear = LinearIndices(physical.board_dim)[neighbor_cart_loc]
#                         neighbor = physical.board[neighbor_loc_linear].occupant
#                         if neighbor > 0
#                             neighbor_health = physical.agent[neighbor].health
#                             # If the neighbor is susceptible, then it can become infected.
#                             neighbor_health == Healthy
#                         else
#                             false
#                         end
#                     else
#                         false
#                     end
#                 end
#             end

#             # Then back to the inserted code.
#             clock_key(transition) in existing_events && continue
#             # The point of this is to make a new transition.
#             push!(sym_create, transition)
#             # That transition depends on the input places just read during @condition.
#             push!(sym_depends, input_places)
#             push!(sym_enabled, enable_func)
#         end
#     end
#     if isempty(sym_create)
#         return nothing
#     else
#         return (create=sym_create, depends=sym_depends, enabled=sym_enabled)
#     end
# end


function modify(tn::MoveTransition, physical)
    false
end


"""
Whether two individuals are adjacent.
"""
function isadjacent(physical::PhysicalState, inda, indb)
    loca = physical.loc[inda]
    locb = physical.loc[indb]
    return loca == locb || any(
        x -> locb == loca + x,
        values(DirectionDelta)
    )
end


struct InfectTransition <: BoardTransition
    source::Int
    target::Int
    health::Health
end


clock_key(mt::InfectTransition) = ClockKey(:InfectTransition, mt.source, mt.target, mt.health)


function health_generate_event(physical, place)
    create = ClockKey[]
    array_name, location = place
    if array_name == :board
        agent = physical.board[location]
        if agent > 0
            agent_health = physical.health[agent]
            for delta in values(DirectionDelta)
                neighbor = physical.board[location + delta]
                neighbor_health = physical.health[neighbor]
                if agent_health == Sick && neighbor_health == Healthy
                    push!(create, (agent, CartesianIndex(neighbor, 0), Infect))
                elseif agent_health == Health && neighbor_health == Sick
                    push!(create, (neighbor, CartesianIndex(agent, 0), Infect))
                end
            end
        end
    elseif array_name == :health
        agent = location[1]
        if physical.health[agent] == Sick
            for delta in values(DirectionDelta)
                neighbor_loc = physical.loc[agent] + delta
                neighbor = physical.board[neighbor_loc]
                if neighbor != 0 && physical.health[neighbor] == Healthy
                    push!(create, (agent, neighbor_loc, Infect))
                end
            end
        end
    end
    return create
end

function check_places(physical, tn::InfectTransition)
    return PlaceKey[
        (:board, physical.loc[tn.source]), (:board, physical.loc[tn.target]),
        (:health, tn.source), (:health, tn.target)
        ]
end


function enable(tn::InfectTransition, sampler, physical, when, rng)
    should = physical.health[tn.source] == Sick &&
        physical.health[tn.target] == Healthy
    if should
        enable!(sampler, clock_key(tn), Exponential(1.0), when, when, rng)
    end
    return should
end


function modify(tn::InfectTransition, physical)
    false
end


# Firing also transitions enabled -> disabled.
function fire!(tn::InfectTransition, physical)
    physical.health[tn.target] = Sick
    return nothing
end


# A transition from enabled -> disabled.
function bdisable(tn::InfectTransition, physical)
    return !isadjacent(physical, tn.source, tn.target) ||
        physical.health[tn.target] != Healthy ||
        physical.health[tn.source] != Sick
end
